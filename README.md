### Вариант 18
## Реализуйте DFS для графа с выводом времени входа и выхода для каждой вершины.


## 1. Детальное пошаговое описание работы алгоритма

### Этап 1: Подготовка и инициализация
1. **Создание структур данных**:
   - Список смежности для хранения графа
   - Массив `visited[]` для отслеживания посещенных вершин (изначально все `false`)
   - Массивы `entry_time[]` и `exit_time[]` для хранения времени входа и выхода
   - Счетчик `timer`, инициализированный значением 1

2. **Построение графа**:
   - Для неориентированного графа добавляем ребра в обе стороны
   - Для ориентированного - только в направлении ребра

### Этап 2: Рекурсивный обход в глубину
3. **Запуск из начальной вершины**:
   - Если граф несвязный, запускаем DFS из всех непосещенных вершин

4. **Обработка вершины при входе**:
   ```
   Шаг 1: Пометить вершину v как посещенную (visited[v] = true)
   Шаг 2: Записать текущее значение timer в entry_time[v]
   Шаг 3: Увеличить timer на 1
   ```

5. **Рекурсивный обход соседей**:
   - Для каждого соседа u вершины v:
     - Если u не посещена, рекурсивно вызвать DFS(u)
   - Порядок обхода соседей зависит от реализации списка смежности

6. **Обработка вершины при выходе**:
   ```
   Шаг 1: Записать текущее значение timer в exit_time[v]
   Шаг 2: Увеличить timer на 1
   Шаг 3: Вернуться к родительской вершине
   ```

### Этап 3: Пример выполнения для графа 0-1-2
```
Время: 1 - Вход в 0, timer=1
Время: 2 - Вход в 1, timer=2
Время: 3 - Вход в 2, timer=3
Время: 4 - Выход из 2, timer=4
Время: 5 - Выход из 1, timer=5
Время: 6 - Выход из 0, timer=6
```

## 2. Детальная оценка временной сложности

### Временная сложность:
- **O(V + E)** где:
  - V - количество вершин (vertices)
  - E - количество ребер (edges)

## 3. Подробное объяснение временной сложности

### Разбор сложности O(V + E):

1. **Инициализация массивов**: O(V)
   - Создание и заполнение массивов размера V

2. **Обход вершин**: O(V)
   - Каждая вершина посещается ровно один раз
   - Операции пометки посещения и записи времени - O(1)

3. **Обход ребер**: O(E)
   - Каждое ребро проверяется ровно один раз (в неориентированном графе - дважды)
   - Для каждого ребра выполняются проверки O(1)

4. **Рекурсивные вызовы**: O(V) для стека вызовов

### Почему не O(V × E)?
- Каждая вершина и каждое ребро обрабатываются константное количество раз
- Нет вложенных циклов по V и E одновременно

### Наихудший случай:
- **Плотный граф**: E ≈ V², сложность O(V²)
- **Разреженный граф**: E ≈ V, сложность O(V)

## 4. Развернутый ответ по теме

Алгоритм Depth-First Search (DFS) с отслеживанием времени входа и выхода представляет собой модификацию классического обхода в глубину, где каждая вершина получает временные метки. **Время входа** (discovery time) отмечает момент первого посещения вершины, а **время выхода** (finishing time) - момент завершения обработки всех ее потомков. 

Ключевое свойство: для любых двух вершин u и v, интервалы [entry[u], exit[u]] и [entry[v], exit[v]] либо не пересекаются, либо один полностью содержится в другом. Это позволяет эффективно проверять отношения "предок-потомок" в дереве обхода за O(1).

## 5. Расширенные примеры вводных и выводимых данных

### Пример 1: Простое дерево
```
Входные данные:
Вершины: 5
Ребра: 0-1, 0-2, 1-3, 1-4

Граф:
    0
   / \
  1   2
 / \
3   4

Выходные данные:
Вершина 0: вход = 1, выход = 10
Вершина 1: вход = 2, выход = 7
Вершина 2: вход = 8, выход = 9
Вершина 3: вход = 3, выход = 4
Вершина 4: вход = 5, выход = 6
```

### Пример 2: Граф с циклами
```
Входные данные:
Вершины: 4
Ребра: 0-1, 1-2, 2-3, 3-0

Граф:
0 -- 1
|    |
3 -- 2

Выходные данные:
Вершина 0: вход = 1, выход = 8
Вершина 1: вход = 2, выход = 7
Вершина 2: вход = 3, выход = 6
Вершина 3: вход = 4, выход = 5
```

### Пример 3: Несвязный граф
```
Входные данные:
Вершины: 6
Ребра: 0-1, 1-2, 3-4, 4-5

Граф:
0-1-2   3-4-5

Выходные данные:
Вершина 0: вход = 1, выход = 6
Вершина 1: вход = 2, выход = 5
Вершина 2: вход = 3, выход = 4
Вершина 3: вход = 7, выход = 12
Вершина 4: вход = 8, выход = 11
Вершина 5: вход = 9, выход = 10
```
